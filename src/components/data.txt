const onSubmit = handleSubmit(async (data: FormValues) => {
  try {
    console.log('onSubmit called with data:', JSON.parse(JSON.stringify(data)))
    // clear errors
    otherMethodError.value = null
    invoiceError.value = null
    nameError.value = null
    makerError.value = null
    amountError.value = null

    // manual validation (avoid using library rules which were causing persistent messages)
    if (!data.name || String(data.name).trim() === '') {
      nameError.value = 'Expense name is required.'
    }
    if (!data.maker || String(data.maker).trim() === '') {
      makerError.value = 'Expense maker is required.'
    }
    const parsedAmt = typeof data.amount === 'string' ? parseFloat(String(data.amount)) : data.amount
    console.log('parsedAmt:', parsedAmt, 'typeof:', typeof parsedAmt)
    if (isNaN(Number(parsedAmt))) {
      amountError.value = 'Amount must be a number.'
    }
    if (nameError.value || makerError.value || amountError.value) {
      console.log('manual validation failed', { nameError: nameError.value, makerError: makerError.value, amountError: amountError.value })
      return
    }

    // conditional required validation for 'OTHERS'
    if (data.method === 'OTHERS' && (!data.otherMethod || data.otherMethod.trim() === '')) {
      otherMethodError.value = 'Other payment method is required.'
      console.log('other method validation failed')
      return
    }

    // invoice file required only if checkbox is checked
    if (data.hasInvoice && !invoice.value) {
      invoiceError.value = 'Invoice file is required when Invoice is checked.'
      console.log('invoice required validation failed')
      return
    }
  } catch (err) {
    console.error('onSubmit unexpected error', err)
    return
  }

  const amt = typeof data.amount === 'string' ? parseFloat(String(data.amount)) : data.amount
  const methodLabel = data.method === 'OTHERS' && data.otherMethod ? data.otherMethod : data.method

  const newExpense: Expense & { methodLabel?: string } = {
    name: data.name,
    maker: data.maker,
    amount: amt,
    method: data.method,
    otherMethod: data.otherMethod,
    invoice: invoice.value,
    invoiceName: invoiceName.value
  }
  ;(newExpense as any).methodLabel = methodLabel

  expenses.value.push(newExpense)
  console.log('expenses after push (onSubmit):', expenses.value.length, JSON.parse(JSON.stringify(expenses.value.map(e => ({ name: e.name, amount: e.amount })))) )

  // prevent watchers from re-enabling errors while we programmatically clear fields
  suppressWatch.value = true

  // reset to defaults
  set({ name: '', maker: '', amount: 0, method: 'UPI', otherMethod: '', hasInvoice: false, invoice: null, invoiceName: '' })

  // also explicitly set individual field values to ensure v-model updates immediately
  name.value = ''
  maker.value = ''
  amount.value = 0
  method.value = 'UPI'
  otherMethod.value = ''
  hasInvoice.value = false
  invoice.value = null
  invoiceName.value = ''

  // clear any file input DOM value and local errors
  if (invoiceInput.value) invoiceInput.value.value = ''
  otherMethodError.value = null
  invoiceError.value = null

  // give watchers a tick to run (they might re-validate) then remove errors and remount
  await nextTick()
  clearFormErrors()
  clearFieldErrors()

  // re-enable watchers and suppress showing errors until user edits
  suppressWatch.value = false
  hideErrors.value = true

  // remount form so any remaining internal validation/UI state is cleared
  formKey.value += 1

  // delayed cleanup: some internal watchers may re-validate and re-add errors after remount;
  // remove those keys on the next macrotask and log the final errors for debugging
  setTimeout(() => {
    try { console.log('form errors after submit (delayed):', JSON.parse(JSON.stringify(errors))) } catch (e) { console.log('form errors after submit (delayed):', errors) }
    // log amount value/type
    try { console.log('amount value (get):', get('amount'), 'typeof:', typeof get('amount')) } catch (e) { console.log('get("amount") not available') }

    // attempt to re-validate amount and then remove any error it creates
    try {
      validateField('amount')
        .then(() => { if ((errors as any).amount) delete (errors as any).amount })
        .catch((err: any) => { console.log('validateField(amount) error:', err); delete (errors as any).amount })
    } catch (err) {
      console.log('validateField not available', err)
      delete (errors as any).amount
    }

    ;['name', 'maker', 'amount', 'otherMethod'].forEach((k) => { delete (errors as any)[k] })
  }, 0)
})